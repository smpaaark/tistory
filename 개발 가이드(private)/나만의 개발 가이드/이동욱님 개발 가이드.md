## 프로젝트 생성
* 스프링 이니셜라이져 사용하지 않고 직접 세팅
* Gradle 사용
* junit-vintage-engine 의존성 추가(JUnit4 사용)
* View템플릿 Mustache 사용
* 메인 클래스명 Application.java로 변경
* 메인 클래스 테스트 파일 삭제
* application.properties 사용

## 깃과 깃허브 사용
* .gitignore로 .idea와 .mvn 또는 .gradle 파일 제외

## 패키지 구조
* web: 컨트롤러와 관련된 클래스
  * dto: 모든 응답 Dto 클래스
* domain: 도메인을 담을 패키지
  * 도메인별 패키지 생성: 도메인 + Repository
* serivice: 서비스를 담을 패키지
  * 도메인별 패키지 생성 


## 프로젝트 환경 세팅 테스트
* Hello Controller 테스트
  * 이때는 컨트롤러만 테스트하기 때문에 @WebMvcTest(controllers = HelloController.class) 사용
* 브라우저 결과로 확인
* 롬복 테스트

## 데이터베이스
* 인메모리 H2 사용

## 프로퍼티 설정
* 콘솔에서 쿼리 로그 확인
```
spring.jpa.show_sql=true
```
* 쿼리 로그 MySQL 버전으로 변경
```
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL57Dialect
spring.jpa.properties.hibernate.dialect.storage_engine=innodb
spring.datasource.hikari.jdbc-url=jdbc:h2:mem:testdb;MODE=MYSQL
spring.datasource.hikari.username=sa
```

## 테스트 관련 정책
* @After를 통해 테스트 데이터 다 지워준다.
* @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) 사용

## DTO 관련 정책
* 필요한 필드만 생성자 생성
* toEntity 메서드 생성

## 도메인 관련 정책
* 주요 어노테이션을 클래스에 가깝게 둔다.
* @GenerateValue(GenerationType.IDENTITY) 사용
* PK는 무조건 Long 타입의 Auto_increment
* @Builder 사용
* Setter는 만들지 않는다.
* 비즈니스 로직 처리
* 절대 Request/Response 클래스로 사용하지 않는다.

## 서비스 관련 정책
* 트랜잭션, 도메인 간 순서 보장 역할만 한다.
* 생성자 주입 방식 사용