## 상속을 고려한 설계와 문서화
```상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 합니다.``` 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 합니다. ('재정의 가능'이란 public과 protected 메서드 중 final이 아닌 모든 메서드를 뜻합니다.)

API 문서의 메서드 설명 끝에서 종종 "Implementation Requirements"로 시작하는 절을 볼 수 있는데, 그 메서드의 내부 동작 방식을 설명하는 곳입니다. 이 절은 메서드 주석에 \@implSpec 태그를 붙여주면 자바독 도구가 생성해줍니다. 다음은 java.util.AbstractCollection에서 발췌한 예입니다.
> public boolean remove(Object o)
>
> 주어진 원소가 이 컬렉션 안에 있다면 그 인스턴스를 하나 제거한다(선택적 동작). 더 정확하게 말하면, 이 컬렉션 안에 'Object.equals(o, e)가 참인 원소' e가 하나 이상 있다면 그 중 하나를 제거한다. 주어진 원소가 컬렉션 안에 있었다면 (즉, 호출 결과 이 컬렉션이 변경됐다면) true를 반환한다.
> Implementation Requirements: 이 메서드는 컬렉션을 순회하며 주어진 원소를 찾도록 구현되었다. 주어진 원소를 찾으면 반복자의 remove 메서드를 사용해 컬렉션에서 제거한다. 이 컬렉션이 주어진 객체를 갖고 있으나, 이 컬렉션의 iterator 메서드가 반환한 반복자가 remove 메서드를 구현하지 않았다면 UnsupportedOperationException을 던지니 주의하자.

* HashSet을 상속하여 add를 재정의한 것이 addAll에 영향을 준다는 사실을 알 수 없었는데, 아주 대조적입니다.

하지만 이런 식으로 클래스를 안전하게 상속할 수 있도록 하려면 (상속만 아니었다면 기술하지 않았어야 할) 내부 구현 방식을 설명해야만 합니다.

## \@implSpec
\@implSpec 태그는 자바 8에서 처음 도입되어 자바 9부터 본격적으로 사용되기 시작했습니다. 이 태그가 기본값으로 활성화되어야 바람직하다고 생각하지만 자바 11의 자바독에서도 선택사항으로 남겨져 있습니다. 이 태그를 활성화화려면 명령줄 매개변수로 -tag "implSpec:a:Implementation Requirements:"를 지정해주면 됩니다.

## 훅(hook) 선별 후 protected 메서드 형태로 공개
효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 ```클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있습니다.``` java.util.AbstractList의 removeRange 메서드를 예로 살펴보겠습니다.
> protected void removeRange(int fromIndex, int toIndex)
>
> fromIndex(포함)부터 toIndex(미포함)까지의 모든 원소를 이 리스트에서 제거한다. toIndex 이후의 원소들은 앞으로 (index만큼씩) 당겨진다. 이 호출로 리스트는 'toIndex - fromIndex'만큼 짧아진다. (toIndex == fromIndex라면 아무런 효과가 없다.)
> 이 리스트 혹은 이 리스트의 부분리스트에 정의된 clear 연산이 이 메서드를 호출한다. 리스트 구현의 내부 구조를 활용하도록 이 메서드를 재정의하면 이 리스트와 부분리스트의 clear 연산 성능을 크게 개선할 수 있다.
> Implementation Requirements: 이 메서드는 fromIndex에서 시작하는 리스트 반복자를 얻어 모든 원소를 제거할 때까지 ListInterator.next와 ListIterator.remove를 반복 호출하도록 구현되었다. 주의: ListIterator.remove가 선형 시간이 걸리면 이 구현의 성능은 제곱에 비례한다.
>
> Parameters:
>   fromIndex 제거할 첫 원소의 인덱스
>   toIndex   제거할 마지막 원소의 다음 인덱스

* 이 메서드를 제공하는 이유는 단지 하위 클래스에서 부분리스트의 clear 메서드를 고성능으로 만들기 쉽게 하기 위해서입니다.

## 상속용 클래스를 설계할 때 어떤 메서드를 protected로 노출해야할지 결정하는 방법
심사숙고해서 잘 예측해본 다음, 실제 하위 클래스를 만들어 시험해보는 것이 최선입니다. protected 메서드 하나하나가 내부 구현에 해당하므로 그 수는 가능한 한 적어야 합니다. 한편으로는 너무 적게 노출해서 상속으로 얻는 이점마저 없애지 않도록 주의해야 합니다.

## 상속용 클래스를 시험하는 방법
```상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 '유일'합니다.``` 꼭 필요한 protected 멤버를 놓쳤다면 하위 클래스를 작성할 때 그 빈자리가 확연히 드러납니다. 거꾸로, 하위 클래스를 여러 개 만들 때까지 전혀 쓰이지 않는 protected 멤버는 사실 private이었어야 할 가능성이 큽니다. 이러한 검증에는 하위 클래스 3개 정도가 적당합니다. 그리고 이 중 하나 이상은 제 3자가 작성해봐야 합니다.

널리 쓰일 클래스를 상속용으로 설계한다면 여러분이 문서화한 내부 사용 패턴과, protected 메서드와 필드를 구현하면서 선택한 결정에 영원히 책임져야 함을 잘 인식해야 합니다. 그러니 ```상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 합니다.```

## 생성자 관련 지켜야 할 제약
```상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 됩니다.``` 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출됩니다. 이때 그 재정의한 메서드가 하위 클래스의 생성자에서 초기화하는 값에 의존한다면 의도대로 동작하지 않을 것입니다.
```
public class Super {

    // 잘못된 예 - 생성자가 재정의 가능 메서드를 호출한다.
    public Super() {
        overrideMe();
    }

    public void overrideMe() {
    }

}
```

상위 클래스의 생성자가 호출해 오동작을 일으키는 메서드 예시입니다.
```
public final class Sub extends Super {

    // 초기화되지 않은 final 필드. 생성자에서 초기화한다.
    private final Instant instant;

    Sub() {
        instant = Instant.now();
    }

    // 재정의 가능 메서드. 상위 클래스의 생성자가 호출한다.
    @Override public void overrideMe() {
        System.out.println(instant);
    }

    public static void main(String[] args) {
        Sub sub = new Sub();
        sub.overrideMe();
    }

}
```
* 이 프로그램이 instant를 두 번 출력하리라 기대했겠지만, 첫 번째는 null을 출력합니다.
* 상위 클래스의 생성자는 하위 클래스의 생성자가 인스턴스 필드를 초기화하기도 전에 overrideMe를 호출하기 때문입니다.

> private, final, static 메서드는 재정의가 불가능하니 생성자에서 안심하고 호출해도 됩니다.

## Cloneable과 Serializable 인터페이스
Cloneable과 Serializable 인터페이스는 상속용 설계의 어려움을 한층 더해줍니다. 둘 중 하나라도 구현한 클래스를 상속할 수 있게 설계하는 것은 일반적으로 좋지 않은 생각입니다. 

### clone과 readObject 메서드
clone과 readObject 메서드는 생성자와 비슷한 효과를 냅니다(새로운 객체를 만듭니다). ```clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 됩니다.``` 

Serializable을 구현한 상속용 클래스가 readResolve나 write Replace 메서드를 갖는다면 이 메서드들은 private이 아닌 protected로 선언해야 합니다. private으로 선언한다면 하위 클래스에서 무시되기 때문입니다.

이제 ```클래스를 상속용으로 설계하려면 엄청난 노력이 들고 그 클래스에 안기는 제약도 상당함을 알았습니다.``` 추상 클래스나 인터페이스의 골격 구현처럼 상속을 허용하는 게 명백히 정당한 상황이 있고, 불변 클래스처럼 명백히 잘못된 상황이 있습니다.

## 일반적인 구체 클래스
전통적으로 일반적인 구체 클래스는 final도 아니고 상속용으로 설계되거나 문서화되지도 않았습니다. 이 경우 클래스에 변화가 생길 때마다 하위 클래스를 오동작하게 만들 수 있습니다.

### 해결 방법
```이 문제를 해결하는 가장 좋은 방법은 상속용으로 설계하지 않은 클래스는 상속을 금지하는 것입니다.``` 상속을 금지하는 방법은 두 가지입니다. 둘 중 더 쉬운 쪽은 클래스를 final로 선언하는 방법입니다. 두 번째 선택지는 모든 생성자를 private이나 package-private으로 선언하고 public 정적 팩터리를 만들어주는 방법입니다. 정적 팩터리 방법은 내부에서 다양한 하위 클래스를 만들어 쓸 수 있는 유연성을 줍니다.

구체 클래스가 표준 인터페이스를 구현하지 않았는데 상속을 금지하면 사용하기에 상당히 불편해집니다. 이런 클래스라도 상속을 꼭 허용해야겠다면 합당한 방법이 있습니다. 클래스 내부에서는 재정의 가능 메서드를 사용하지 않게 만들고 이 사실을 문서로 남기는 것입니다. 이렇게 하면 상속해도 그리 위험하지 않은 클래스를 만들 수 있습니다.

## 클래스의 동작을 유지하면서 재정의 가능 메서드를 사용하는 코드를 제거할 수 있는 방법
클래스의 동작을 유지하면서 재정의 가능 메서드를 사용하는 코드를 제거할 수 있는 기계적인 방법을 소개합니다. 먼저 각각의 재정의 가능 메서드는 자신의 본문 코드를 private '도우미 메서드'로 옮기고, 이 도우미 메서드를 호출하도록 수정합니다. 그런 다음 재정의 가능 메서드를 호출하는 다른 코드들도 모두 이 도우미 메서드를 직접 호출하도록 수정하면 됩니다.

## 핵심 정리
> 상속용 클래스를 설계하기란 결코 만만치 않습니다. 클래스 내부에서 스스로를 어떻게 사용하는지 (자기사용 패턴) 모두 문서로 남겨야 하며, 일단 문서화한 것은 그 클래스가 쓰이는 한 반드시 지켜야 합니다. 그러지 않으면 그 내부 구현 방식을 믿고 활용하던 하위 클래스를 오동작하게 만들 수 있습니다. 다른 이가 효율 좋은 하위 클래스를 만들 수 있도록 일부 메서드를 protected로 제공해야 할 수도 있습니다. 그러니 클래스를 확장해야 할 명확한 이유가 떠오르지 않으면 상속을 금지하는 편이 나을 것입니다. 상속을 금지하려면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들면 됩니다.

## 참조
* [Effective Java 3판](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9788966262281)